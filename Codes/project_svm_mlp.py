# -*- coding: utf-8 -*-
"""project_svm_mlp.ipynb

Automatically generated by Colaboratory.

# Reading the data
"""

from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from sklearn.model_selection import GridSearchCV
from sklearn.neural_network import MLPClassifier
from sklearn.datasets import fetch_lfw_people
from sklearn.datasets import fetch_lfw_pairs
from matplotlib import pyplot as plt
from sklearn import svm
from PIL import Image
import numpy as np
import random

# Commented out IPython magic to ensure Python compatibility.
from __future__ import absolute_import, division, print_function, unicode_literals
try:
#   %tensorflow_version 2.x
except Exception:
  pass
  
import tensorflow_datasets as tfds
import tensorflow as tf
tf.test.gpu_device_name()

from google.colab import drive
drive.mount('/content/drive')

data=fetch_lfw_people(resize=0.4,min_faces_per_person=40,funneled=True)

l=list(data.keys())
X=data[l[0]]
Y=data[l[2]]
target_name=data[l[3]]

_,W,H=data[l[1]].shape
features=X.shape[1]
m=X.shape[0]
classes=data[l[3]].shape[0]

print("Samples:",m)
print("Features:",features)
print("Classes:",classes)
print("Dimension:",(W,H))

"""# Sample Images"""

for i in range(6):
  img=X[i,:]
  img=img.reshape(W,H)
  plt.subplot(2,3,i+1)
  plt.title(target_name[Y[i]])
  plt.imshow(img,cmap='gray')
  plt.axis('off')
plt.show()

"""# Shuffling the data"""

temp=list(zip(X,Y)) 
random.shuffle(temp) 
X,Y=zip(*temp)

X=np.array(X)
Y=np.array(Y)

"""# Train and test splitting of data"""

#train_size=(m*80)//100
#test_size=(m*20)//100

#training_data_X=np.delete(X,[i for i in range(test_size) ],axis=0)
#training_data_Y=np.delete(Y,[i for i in range(test_size) ],axis=0)
#testing_data_X=X[0:test_size,:]
#testing_data_Y=Y[0:test_size]

training_data_X,testing_data_X,training_data_Y,testing_data_Y=train_test_split(X,Y,test_size=0.20,random_state=42)

"""# Linear SVM"""

svm_linear=svm.SVC(kernel='linear',probability=True)
svm_linear=svm_linear.fit(training_data_X,training_data_Y)

print(svm_linear.score(testing_data_X,testing_data_Y)*100)

"""# RBF SVM"""

svm_rbf=svm.SVC(kernel='rbf',gamma='scale',C=10,probability=True)
svm_rbf=svm_rbf.fit(training_data_X,training_data_Y)

print(svm_rbf.score(testing_data_X,testing_data_Y)*100)

"""# Quadratic SVM"""

svm_quad=svm.SVC(kernel='poly',degree=2,gamma='scale',probability=True)
svm_quad=svm_quad.fit(training_data_X,training_data_Y)

print(svm_quad.score(testing_data_X,testing_data_Y)*100)

"""# Classification Report"""

y_pred=svm_linear.predict(testing_data_X)
print(classification_report(testing_data_Y,y_pred,target_names=target_name))

y_pred=svm_rbf.predict(testing_data_X)
print(classification_report(testing_data_Y,y_pred,target_names=target_name))

y_pred=svm_quad.predict(testing_data_X)
print(classification_report(testing_data_Y,y_pred,target_names=target_name))

"""# ROC Curve"""

!pip install scikit-plot
import matplotlib.pyplot as plt
import scikitplot as skplt

predict_l=svm_linear.predict_proba(testing_data_X)
predict_rbf=svm_rbf.predict_proba(testing_data_X)
predict_q=svm_quad.predict_proba(testing_data_X)

skplt.metrics.plot_roc(testing_data_Y,predict_l,title="ROC plot for linear kernel")
plt.savefig('/content/drive/My Drive/Jupyter/linear.png')
#plt.legend('')
plt.show()

skplt.metrics.plot_roc(testing_data_Y,predict_rbf,title="ROC plot for rbf kernel")
plt.savefig('/content/drive/My Drive/Jupyter/rbf.png')
#plt.legend('')
plt.show()

skplt.metrics.plot_roc(testing_data_Y,predict_q,title="ROC plot for Quadratic kernel")
plt.savefig('/content/drive/My Drive/Jupyter/quadratic.png')
#plt.legend('')
plt.show()

"""# MLP"""

mlp=MLPClassifier(hidden_layer_sizes=(64,128,256,512,1024,1024),activation='relu',solver='lbfgs')
mlp.fit(training_data_X,training_data_Y)
print("Accuracy of ReLU Neural Net:",mlp.score(testing_data_X,testing_data_Y)*100)

mlp=MLPClassifier(hidden_layer_sizes=(64,128,256,512,1024,1024),activation='identity',solver='lbfgs')
mlp.fit(training_data_X,training_data_Y)
print("Accuracy of ReLU Neural Net:",mlp.score(testing_data_X,testing_data_Y)*100)

mlp=MLPClassifier(hidden_layer_sizes=(64,128,256,512,1024,1024),activation='logistic',solver='lbfgs')
mlp.fit(training_data_X,training_data_Y)
print("Accuracy of ReLU Neural Net:",mlp.score(testing_data_X,testing_data_Y)*100)

